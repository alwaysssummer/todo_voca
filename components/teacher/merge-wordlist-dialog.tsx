'use client'

import { useState, useEffect } from 'react'
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import { Badge } from '@/components/ui/badge'
import { Card } from '@/components/ui/card'
import { Alert, AlertDescription } from '@/components/ui/alert'
import { Loader2, Merge, AlertCircle, CheckCircle2 } from 'lucide-react'
import { supabase } from '@/lib/supabase'

interface Word {
  id: number
  wordlist_id: string
  word_text: string
  meaning: string
  example?: string
  example_translation?: string
  mnemonic?: string
  sequence_order: number
}

interface WordlistInfo {
  id: string
  name: string
  totalWords: number
  isAutoGenerated?: boolean
}

interface MergeWordlistDialogProps {
  open: boolean
  onClose: () => void
  wordlistIds: string[]
  onSuccess: () => void
}

interface MergeResult {
  uniqueWords: Word[]
  duplicates: string[]
}

/**
 * 중복 단어 자동 제거
 * - word_text 기준 (대소문자 무시, 공백 정규화)
 * - 첫 번째 출현만 유지
 */
function removeDuplicateWords(words: Word[]): MergeResult {
  const seen = new Map<string, Word>()
  const duplicates: string[] = []
  
  for (const word of words) {
    // 정규화: 소문자 + 앞뒤 공백 제거 + 연속 공백 → 단일 공백
    const normalized = word.word_text
      .toLowerCase()
      .trim()
      .replace(/\s+/g, ' ')
    
    if (seen.has(normalized)) {
      duplicates.push(word.word_text)
    } else {
      seen.set(normalized, word)
    }
  }
  
  return {
    uniqueWords: Array.from(seen.values()),
    duplicates
  }
}

export function MergeWordlistDialog({
  open,
  onClose,
  wordlistIds,
  onSuccess
}: MergeWordlistDialogProps) {
  const [mergedName, setMergedName] = useState('')
  const [wordlistsInfo, setWordlistsInfo] = useState<WordlistInfo[]>([])
  const [totalWords, setTotalWords] = useState(0)
  const [isMerging, setIsMerging] = useState(false)
  const [error, setError] = useState('')
  const [loadingPreview, setLoadingPreview] = useState(true)

  // 미리보기 데이터 로드
  useEffect(() => {
    if (open && wordlistIds.length > 0) {
      loadPreview()
    }
  }, [open, wordlistIds])

  const loadPreview = async () => {
    try {
      setLoadingPreview(true)
      
      // 선택된 단어장 정보 가져오기 (순서 보장)
      const wordlistsData: WordlistInfo[] = []
      let total = 0
      
      for (const id of wordlistIds) {
        const { data: wordlist, error } = await supabase
          .from('wordlists')
          .select('id, name, total_words')
          .eq('id', id)
          .single()
        
        if (error) throw error
        
        wordlistsData.push({
          id: wordlist.id,
          name: wordlist.name,
          totalWords: wordlist.total_words
        })
        
        total += wordlist.total_words
      }
      
      setWordlistsInfo(wordlistsData)
      setTotalWords(total)
      
      // 기본 이름 제안
      if (!mergedName) {
        const defaultName = `통합 단어장 (${total}개)`
        setMergedName(defaultName)
      }
      
    } catch (err: any) {
      console.error('미리보기 로드 오류:', err)
      setError('단어장 정보를 불러올 수 없습니다')
    } finally {
      setLoadingPreview(false)
    }
  }

  const handleMerge = async () => {
    setIsMerging(true)
    setError('')
    
    try {
      // ============================================
      // STEP 1: 유효성 검사
      // ============================================
      
      if (wordlistIds.length < 2) {
        throw new Error('2개 이상의 단어장을 선택해주세요')
      }
      
      const trimmedName = mergedName.trim()
      if (!trimmedName) {
        throw new Error('단어장 이름을 입력해주세요')
      }
      
      // 이름 중복 확인
      const { data: existing } = await supabase
        .from('wordlists')
        .select('id')
        .eq('name', trimmedName)
        .maybeSingle()
      
      if (existing) {
        throw new Error('이미 존재하는 이름입니다')
      }
      
      // ============================================
      // STEP 2: 단어 수집 (선택 순서 보장)
      // ============================================
      
      const allWords: Word[] = []
      
      for (const wordlistId of wordlistIds) {
        const { data: words, error } = await supabase
          .from('words')
          .select('*')
          .eq('wordlist_id', wordlistId)
          .order('sequence_order')
        
        if (error) throw error
        allWords.push(...(words || []))
      }
      
      const totalCollected = allWords.length
      console.log(`📊 수집된 총 단어: ${totalCollected}개`)
      
      // ============================================
      // STEP 3: 중복 제거 ⭐
      // ============================================
      
      const { uniqueWords, duplicates } = removeDuplicateWords(allWords)
      
      console.log(`✂️ 중복 제거: ${duplicates.length}개`)
      console.log(`✅ 최종 단어: ${uniqueWords.length}개`)
      
      if (uniqueWords.length === 0) {
        throw new Error('통합할 단어가 없습니다')
      }
      
      // ============================================
      // STEP 4: 새 단어장 생성
      // ============================================
      
      const teacherId = sessionStorage.getItem('teacher_id') || localStorage.getItem('teacher_id')
      
      const { data: newWordlist, error: wordlistError } = await supabase
        .from('wordlists')
        .insert({
          name: trimmedName,
          total_words: uniqueWords.length,
          created_by: teacherId,
          created_at: new Date().toISOString()
        })
        .select()
        .single()
      
      if (wordlistError) throw wordlistError
      
      console.log(`✅ 단어장 생성: ${newWordlist.id}`)
      
      // ============================================
      // STEP 5: 단어 INSERT (Batch + sequence 재정렬)
      // ============================================
      
      const wordsToInsert = uniqueWords.map((word, index) => ({
        wordlist_id: newWordlist.id,
        word_text: word.word_text,
        meaning: word.meaning,
        example: word.example || null,
        example_translation: word.example_translation || null,
        mnemonic: word.mnemonic || null,
        sequence_order: index + 1  // ⭐ 1부터 재정렬
      }))
      
      // Batch INSERT (100개씩)
      const BATCH_SIZE = 100
      try {
        for (let i = 0; i < wordsToInsert.length; i += BATCH_SIZE) {
          const batch = wordsToInsert.slice(i, i + BATCH_SIZE)
          const { error: insertError } = await supabase
            .from('words')
            .insert(batch)
          
          if (insertError) throw insertError
        }
      } catch (insertError: any) {
        // 롤백: 단어장 삭제 (CASCADE로 단어도 자동 삭제)
        console.error('단어 INSERT 실패, 롤백 중...')
        await supabase
          .from('wordlists')
          .delete()
          .eq('id', newWordlist.id)
        
        throw insertError
      }
      
      // ============================================
      // STEP 6: 성공 알림
      // ============================================
      
      let message = `✅ "${trimmedName}" 단어장이 생성되었습니다!\n\n`
      message += `📊 통계:\n`
      message += `- 선택한 단어장: ${wordlistIds.length}개\n`
      message += `- 수집된 단어: ${totalCollected}개\n`
      
      if (duplicates.length > 0) {
        message += `- 중복 제거: ${duplicates.length}개\n`
        if (duplicates.length <= 5) {
          message += `  (${duplicates.join(', ')})\n`
        } else {
          message += `  (${duplicates.slice(0, 5).join(', ')} 외 ${duplicates.length - 5}개)\n`
        }
      }
      
      message += `- 최종 생성: ${uniqueWords.length}개\n\n`
      message += `⚠️ 중요 안내:\n`
      message += `이 통합 단어장은 신규 학생에게 배정을 권장합니다.\n`
      message += `(기존 학생 배정 시 학습 기록이 초기화됩니다)`
      
      alert(message)
      
      // 성공 후 초기화 및 새로고침
      onSuccess()
      handleClose()
      
    } catch (error: any) {
      console.error('❌ 통합 실패:', error)
      setError(error.message || '통합 중 오류가 발생했습니다')
    } finally {
      setIsMerging(false)
    }
  }

  const handleClose = () => {
    setMergedName('')
    setWordlistsInfo([])
    setTotalWords(0)
    setError('')
    setLoadingPreview(true)
    onClose()
  }

  return (
    <Dialog open={open} onOpenChange={handleClose}>
      <DialogContent className="sm:max-w-[500px]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Merge className="w-5 h-5" />
            단어장 통합
          </DialogTitle>
          <DialogDescription>
            선택한 단어장을 하나로 통합합니다 (중복 단어 자동 제거)
          </DialogDescription>
        </DialogHeader>

        {loadingPreview ? (
          <div className="flex items-center justify-center py-8">
            <Loader2 className="w-6 h-6 animate-spin text-muted-foreground" />
          </div>
        ) : (
          <div className="space-y-4">
            {/* 선택된 단어장 목록 */}
            <Card className="p-4">
              <div className="space-y-2">
                <Label className="text-sm font-medium">
                  선택된 단어장 ({wordlistIds.length}개)
                </Label>
                <div className="space-y-2 max-h-40 overflow-y-auto">
                  {wordlistsInfo.map((w, idx) => (
                    <div key={w.id} className="flex items-center gap-2 text-sm">
                      <Badge variant="outline" className="shrink-0">
                        {idx + 1}
                      </Badge>
                      <span className="flex-1 truncate">{w.name}</span>
                      <span className="text-muted-foreground shrink-0">
                        {w.totalWords}개
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            </Card>

            {/* 통계 정보 */}
            <Card className="p-4 bg-blue-50 dark:bg-blue-900/20">
              <div className="space-y-1 text-sm">
                <div className="flex justify-between">
                  <span>총 단어 수:</span>
                  <span className="font-semibold">{totalWords}개</span>
                </div>
                <div className="flex justify-between text-muted-foreground text-xs pt-1 border-t">
                  <span>생성 예상:</span>
                  <span>중복 제거 후 확정</span>
                </div>
              </div>
            </Card>

            {/* 새 이름 입력 */}
            <div className="space-y-2">
              <Label htmlFor="merged-name">
                새 단어장 이름 <span className="text-red-500">*</span>
              </Label>
              <Input
                id="merged-name"
                placeholder="예: 통합 단어장 1"
                value={mergedName}
                onChange={(e) => setMergedName(e.target.value)}
                disabled={isMerging}
              />
            </div>

            {/* 안내 메시지 */}
            <Alert>
              <AlertCircle className="h-4 w-4" />
              <AlertDescription className="text-xs space-y-1">
                <div><strong>중복 단어 자동 제거:</strong></div>
                <div>같은 철자의 단어는 하나만 포함됩니다 (첫 번째 단어장 우선)</div>
                <div className="text-orange-600 pt-1">
                  <strong>⚠️ 신규 학생 배정 권장</strong>
                </div>
              </AlertDescription>
            </Alert>

            {/* 에러 메시지 */}
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
          </div>
        )}

        {/* 버튼 */}
        <DialogFooter className="gap-2">
          <Button
            variant="outline"
            onClick={handleClose}
            disabled={isMerging}
          >
            취소
          </Button>
          <Button
            onClick={handleMerge}
            disabled={isMerging || !mergedName.trim() || loadingPreview}
          >
            {isMerging ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                통합 중...
              </>
            ) : (
              <>
                <Merge className="w-4 h-4 mr-2" />
                통합 생성
              </>
            )}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  )
}

